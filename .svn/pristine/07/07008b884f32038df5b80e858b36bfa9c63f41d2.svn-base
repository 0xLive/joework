本工具可将符合一定格式规范要求的Excel表格数据导出为lua能直接使用的lua table数据（需安装微软的AccessDatabaseEngine以提供读取Excel文件的支持）

Excel文件中必须有且仅有一个Sheet名为data的表格用于配置数据。一个可选的Sheet名为config的表格用于配置整表检查规则和导出选项。除这两张表之外，其余表不会被本工具识别，可以用于备份之前版本的表格、存储表格修改记录等

data数据表的前五行用于声明该列对应字段的描述、字段名、数据类型、检查规则、导出到数据库中的字段名，如下所示：
道具名称               -> 字段描述，仅用于方便填表者备注，可不填，不会生成到最终的lua table中
propName               -> 字段名，会被作为table中的key生成，如果某列不填写该字段名，则视为填表格添加的辅助列，该列数据不会被生成
string                 -> 字段数据类型，规定了这列数据的类型，详见下面对支持的数据类型的介绍。若该列字段名有效，则必须一并填写字段的数据类型
unique                 -> 字段检查规则，用于规定对这列数据的检查规则，详见下面对支持的检查规则的介绍，如果该列不需要进行检查则留空
propName(VARCHAR(20))  -> 导出到数据库中的字段名及对应数据库中的数据类型，前面是字段名后面在英文括号中声明数据类型。注意如果某张表格设置了需要导出到数据库，则此表中所有有效字段都需要进行此声明。array或dict类型的父字段上不需要声明，只需要逐个在子元素字段声明即可，但注意数据库字段名不允许同名。对于lang型字段，导出到数据库中的数据为lang文件中对应的value值

其中表格的第一列为主键列，只能为int、long或string型，如果为string型主键，只能由英文字母、数字、下划线组成且不能为空或纯空格

本工具的配置文件config.txt需放在本工具所在目录下，里面用于配置经常变动的自定义表格检查规则。本工具启动时可传入lang文件路径，lang文件用于配置国际化文字对应各种语言的翻译
注意本工具所读取的所有txt格式的配置文件，必须采用UTF-8编码

config配置表中可通过配置列进行整表检查规则、导出规则等的设置，目前支持的参数如下：
① tableCheckRule 用于声明检查整张表格的自定义函数在MyCheckFunction.cs中的函数名，整表检查是为了弥补字段检查的局限性而设立的，比如某张表格配置英雄在不同品阶下可穿戴的四件装备的信息，就需要进行这样的整表检查，即检查表格中是否配置了某个英雄在所有品阶下的可装备信息，并且每个品阶下配置四行装备信息，可以参考HeroEquipment表
② exportDatabaseTableName 用于配置当需要将表格导出到数据库时，此表对应数据库中的表名，如果不填写则不将此表导出到数据库。注意Windows下MySQL默认不分区表名大小写，而Linux下区分（虽然Windows下可通过修改MySQL配置文件my.ini中lower_case_table_names参数为2开启大小写敏感，但MySQL也会报兼容性警告，并且表名虽然可以出现大写，但不支持仅大小写不同的表名），故在使用本工具时需自行确认MySQL数据库的设置，否则即便定义表名中包含大写也会被MySQL强制转为小写形式。另外需注意本工具在导出数据时，会删除同名旧表然后重新创建新表后插入数据
③ tableExportConfig 用于进行特殊规则的导出，比如英雄在不同品质下四个装备槽位可穿戴装备的配置表，一般不会设计为下面这样，因为这样列数过多不宜配表，且如果后期增加品质，代码也需要进行修改
   ID  英雄ID  白色品质下第1个槽位装备ID  绿色品质下第1个槽位装备ID  绿色品质下第2个槽位装备ID  ……  紫色+3品质下第4个槽位装备ID
   1   100001  200001                     200002                     200003                           200040
一般会采用下面的配置方式
   ID  英雄ID  品质  槽位序号  可穿戴装备ID  可穿戴等级限制
   1   100001  10    1         200001        1
   2   100001  10    2         200002        1
   ……
   40  100001  43    4         200040        60
这种方式便于填写与扩展，但是程序在使用这样的表格数据时，为了运行时检索遍历方便，需要建立连续嵌套的索引结构，比如这里会按照英雄ID、品质、槽位序号逐层建立索引结构，使得最终的数据结构为下面的形式：
return {
  [100001] = {
    [10] = {
      [1] = {
        equipmentId = 200001,
        equipRank = 1,
      },
      [2] = {
      ……
      },
      ……
    },
    ……
  },
  ……
}
本工具支持配置相应的特殊导出规则，使得Excel数据表导出的lua文件直接就是这种嵌套索引的结构，程序无需再专门写代码去组织这样的结构
配置参数规则如下：
形如HeroEquipmentDict:heroId-heroQuality-seq{propId,equipRank}  其中英文冒号前声明按这种规则导出的lua文件名，冒号之后声明索引层次，将一层层的索引的字段用英文连字符连接，注意作为索引的字段只能为int、long、float、string、lang型的独立字段，且不允许出现空值，最后在花括号中声明索引出来的table value中包含哪些字段的信息，用英文逗号分隔各个字段名，如果没有在花括号内声明，则默认将索引字段之外的所有字段进行填充
注意：1、不允许出现在各个索引字段值都相同的两行数据，本工具发现这种情况会进行错误提示并中断导出
      2、如果配置了自定义的导出规则而不想让本工具再按默认方式导出lua文件可声明-notExportOriginalTable参数
      3、请自行保证各种特殊导出规则导出的lua文件名设置不同，否则同名的会互相覆盖只留下按最后一个导出参数导出的lua文件，如果未声明不按默认方式导出并且存在特殊导出规则导出的lua文件名与表格名相同，只会保留按默认方式导出的文件

对于类似上面的表格，通常需要保证层层索引中包含所有情况下的值，如HeroEquipment表中凡是配置的英雄，都必须一并配置该英雄在所有品阶下四件装备的信息，虽然用整表检查规则自己写检查函数可以进行检查，但这样需要额外自己写代码并不方便。可以在自定义索引导出规则中用作索引字段的字段名后添加该字段需具备的完整性声明，如写为heroId-heroQuality({10,20,21,30,31,32,40,41,42,43})-seq([1-4]){propId,equipRank}则表示对于某一个heroId，必须具备在10,20……43这些品阶下的穿装信息，并且对于某个英雄某个品阶下的必须具备四件装备信息。注意括号中可使用有效值声明或数值范围声明方式去声明该字段在上层索引到的每个值下都必须包含的所有本字段值的数据行，采用有效值声明方式的字段必须为int、long、float或string型，采用数值范围声明方式的字段只能为int、long型。括号中支持用$声明在config配置文件中的自定义取值范围规则，但不支持用&&声明的多组规则

本工具运行时需要顺序传入以下几个必填参数（参数与参数间用空格分隔）：
① Excel表格所在目录
② 存放导出lua文件的目录
③ 项目Client目录的路径（无需文件存在型检查规则则填-noClient）
④ lang文件路径（没有填-noLang）
后面还可以附加几个功能参数（输入顺序随意）：
① -columnInfo（在生成lua文件的最上方用注释形式显示列信息，默认不开启）
② -unchecked（不对表格进行查错，不推荐使用）
③ -printEmptyStringWhenLangNotMatching（当lang型数据key在lang文件中找不到对应值时，在lua文件输出字段值为空字符串即xx = ""，默认为输出nil）
④ -exportMySQL（将表格数据导出到MySQL数据库中，默认不导出）
⑤ -part（后面在英文小括号内声明本次要导出的Excel文件名，用|分隔，未声明的文件将被本工具忽略。但注意所有Excel仍会被读取，只是声明的Excel文件才会被进行检查并导出，因为要导出的部分Excel中可能含有与未声明要导出的Excel文件存在跨表检查规则）
⑥ -allowedNullNumber（允许int、long、float型字段下填写空值，默认不允许，不建议使用此选项，如果一定要用请务必为逻辑上不允许为空的数值型字段填写notEmpty检查规则）

---------------------------------------------------------------------------------------------------------
支持的数据类型如下：
① string 如果仅是声明string类型，填写的单元格中如果含有空格会被保留。如果声明为string(trim)则会去掉首尾空白字符
② int 整形数字，注意除非设置了-allowedNullNumber参数，否则此类型不允许空值
③ long 整形数字，比int型可以表达更大的数字，注意除非设置了-allowedNullNumber参数，否则此类型不允许空值
④ float 浮点型数字，注意除非设置了-allowedNullNumber参数，否则此类型不允许空值
⑤ bool 填写true或数字1表示真，false或者数字0表示假，其他值非法，不允许空值
⑥ lang 填写在lang文件中的key，生成工具自动找到对应的value进行替换。如果某个字段在lang文件中的key名组成规则相似且至多由其他字段值拼接而成，可以进行统一配置从而不必在这一列的单元格中一一配置，比如道具的描述在lang文件中的key都是itemDesc开头后面紧跟item的id字段的值，则lang类型定义可填写为lang(itemDesc{id})。注意所引用的字段必须在这个lang字段之前声明且不为集合类型子元素，否则无法找到
⑦ date 日期型，包含年月日时分秒的日期格式，格式声明形如date(input=yyyy-MM-dd HH:mm:ss|toLua=#dateTable|toDatabase=#1970sec)，其中有三个可选参数input、toLua和toDatabase，它们的声明需要用|隔开。3个参数的作用如下：
   input规定Excel单元格中填写的格式，有以下2种选项：1、可以填写符合C#类库要求的标准时间格式，如yyyy-MM-dd HH:mm:ss。2、设置为#1970sec表示填写的是距离1970年1月1日的秒数，设置为#1970msec则为毫秒数。若未声明input参数则使用config配置文件中的defaultDateInputFormat配置项
   toLua规定导出至lua文件中的形式，有以下3种选项：1、可以填写符合C#类库要求的标准时间格式，本工具将会按此格式将日期转为string字符串形式，但lua自身类库中不含将string转为时间的库函数，不利于对时间进行后续操作，除非自己编写相应的转换函数或者此时间仅作为界面展示之用，否则不推荐使用这种toLua的输出形式。2、设置为#1970sec或#1970msec，含义同上。3、设置为#dateTable，本工具将导出为os.date("!*t",xxx)这样的代码，其中xxx为时间转成的距离1970年1月1日的秒数，lua在解析导出的lua文件时，上面的lua库函数可将日期转为lua table形式。若未声明toLua参数则使用config配置文件中的defaultDateToLuaFormat配置项
   toDatabase规定导出至数据库中的形式，有以下2种选项：1、可以填写符合C#类库要求的标准时间格式，MySQL数据库中的datetime类型可识别并赋值，也可保存为varchar等文本类型2、设置为#1970sec或#1970msec，适合导出到数值类型的字段。若未声明toDatabase参数则使用config配置文件中的defaultDateToDatabaseFormat配置项
⑧ time 时间型，用时分秒表示一个时间，格式声明形如time(input=HH:mm:ss|toLua=#sec|toDatabase=HH:mm:ss)，其中有三个可选参数input、toLua和toDatabase，它们的声明需要用|隔开。3个参数的作用如下：
   input规定Excel单元格中填写的格式，有以下2种选项：1、可以填写符合C#类库要求的标准时间格式，如HH:mm:ss。2、设置为#sec表示填写的是距离0点的秒数。若未声明input参数则使用config配置文件中的defaultTimeInputFormat配置项
   toLua规定导出至lua文件中的形式，有以下2种选项：1、可以填写符合C#类库要求的标准时间格式，本工具将会按此格式将日期转为string字符串形式。2、设置为#sec，含义同上。若未声明toLua参数则使用config配置文件中的defaultTimeToLuaFormat配置项
   toDatabase规定导出至数据库中的形式，有以下2种选项：1、可以填写符合C#类库要求的标准时间格式，MySQL数据库中的time类型可识别并赋值，也可保存为varchar等文本类型。2、设置为#sec，适合导出到数值类型的字段。若未声明toDatabase参数则使用config配置文件中的defaTimeToDatabaseFormat配置项
⑨ dict 格式为dict[子元素个数]，用于表示组成一个复杂数据结构的相关元素的集合，比如用一个dict可以表示一个reward，dict[3] 其后三列为 type(int)、id(int)、count(int)。注意dict下的子元素不允许出现变量名相同
⑩ array 格式为array[类型:个数]，用于表示多个相同数据结构组成的列表，比如想通过3个数字表示某个试炼活动低中高三个难度的开放等级，则可定义为array[int:3]。注意array类型中的元素会按1、2、3依次作为table的key，无法像dict那样为每个元素指定key名
⑪ tableString 用于以字符串形式表达的复杂嵌套的table结构，格式为tableString[格式]，每组数据的key和value分为用k、v声明，中间用|分隔。特殊符号#seq表示自动按顺序编号，#true表示自动填写value值为true，#table表示value值是一个table，#后加数字表示用填写的该组数据中的第几个表示，自定义的变量在值后面需要在()内标明数据类型，只支持string、int、float、lang、bool这几种最基础类型。填写的具体数据中，两个数据之间用英文分号;隔开，一个数据中的不同变量用英文逗号,隔开。注意整个输入的tableString字符串中不允许出现英文引号、斜杠，string类型字符串中不允许出现英文逗号、分号，lang类型数据所填的key必须在lang文件中能找到对应的字符串值，且字符串中不含有英文引号、斜杠、逗号、分号

   示例：1)比如填写了某一场PVE战斗中的怪物组 10001;10003;10021 填写格式为 tableString[k:#1(int)|v:#true]
           这样程序会生成为：
		{
		   [10001] = true,
		   [10003] = true,
		   [10021] = true,
		}
           如果格式写为  tableString[k:#seq|v:#1(int)]，则程序会生成为:
		{
		   [1] = 10001,
		   [2] = 10003,
		   [3] = 10021,
		}
           推荐采用第1种生成方式，这样可以通过直接索引获知填写的数据中有没有指定数据，而第2种生成的结果就只能for循环遍历后才能获知

         2）比如填写某场战斗后奖励物 1,90001,500;2,90002,10 填写格式为 tableString[k:#seq|v:#table(type=#1(int),id=#2(int),count=#3(int))] 程序会生成为:
		{
		   [1] = {
			    type = 1,
			    id = 90001,
			    count = 500,
			 },
		   [2] = ……
		}
		   

注意：
① dict和array是可以互相嵌套或者自身嵌套自身使用组成更为复杂的数据类型，但均只允许嵌套1次
② dict和array的声明均占用一列，如果某行数据希望该列有效则留空，如果填-1表示该行数据不需要此字段信息。但注意array的子元素中，如果某个子元素字段用-1声明为无效，则后续的子元素也必须声明为无效的。比如配置的某一关推图的奖励列表为array[dict[3]:5]，如果配置时本关卡只奖励两种道具，则必须配置在第1、2个子元素中，后3个子元素标为无效

---------------------------------------------------------------------------------------------------------
表格字段检查支持的规则如下：

首先，表格中第一列为ID列，生成工具会以此列作为lua table的key，该列默认包含unique规则，禁止重复
① [1,10] 用于数值型数据【int、long、float】或时间型数据【date、time】，数字型数据要求取值范围必须在1到10之间，[]表示闭区间，()表示开区间，可以组合使用，比如(1,5]表示一个大于1小于或等于5的范围。如果不限制上下限范围，可以用*代替，比如(*,5]或者[*,5]表示一个小于等于5的数字，同理[5,*]或者[5,*)表示一个大于等于5的数字。时间型数据声明值的填写必须遵循date型为yyyy-MM-dd HH:mm:ss，time型为HH:mm:ss
② {1,5,6} 用于【int、long、float、string、date、time】型，来设定数据取值必须为指定合法取值中的一个，int、long、float、date或time型的值之间用英文逗号分隔即可，但注意date型和time型的填写必须分别遵循yyyy-MM-dd HH:mm:ss和HH:mm:ss，string型的需要在最后面的括号中声明分隔各个有效值的一个字符，比如{a;b}(;)，如果没有声明则默认用英文逗号分隔
③ notEmpty 用于【int、long、float、string、lang、date、time】型，如果是string类型要求字符串不能为空但允许为连续空格字符串，如果也不允许为连续空格字符串，需要声明为notEmpty[trim]。如果是lang类型，填写notEmpty[key]只检查是否填写了key值，填写notEmpty[value]只检查填写的key在相应的lang文件中能找到对应的value，填写notEmpty[key|value]则既要求所有数据都填写lang文件中的key，也要求对应的value在lang文件中都能找到，如果填写notEmpty则与notEmpty[key|value]相同
④ unique 用于【int、long、float、string、lang、date、time】型，要求所有该列数据不能有重复（注意string型、lang型如果填写或者找到的value为空字符串，允许出现多次为空的情况。lang型默认只检查key不能重复，如果还想检查value需要声明为unique[value]
⑤ >=或>后面跟同一表格中另一字段名 表示要检查一张表格中每一行的该字段值必须大于等于或大于另一字段的值，用于【int、long、float、date、time】型，要进行比较的两个字段可以为同种数据类型，也可以任意比较int、long、float三种数值型大小。比如一张表格中某两个字段表示随机掉落指定道具的个数范围，分别叫minCount和maxCount，就需要要求maxCount大于或等于minCount，如果这两个字段为独立字段，则可在maxCount字段的检查规则中声明>=minCount，如果这两个字段假设都是名为dropPropParam的dict字段的子元素，则需要声明为>=dropPropParam.minCount，即用小数点通过层层索引到指定的字段。对于array子元素字段，比如代表推图章节开放战队等级的array型字段openRank，需要检查下一章节的开放战队等级必须大于上一章节，比如比较第一二章时，需要在第二章节的字段检查规则中声明>openRank[1]
⑥ ref 用于【int、long、float、string】型，要求该列的值必须存在于另外某个表格中的一列（注意要检查引用关系的两列必须为相同的数据类型，string型数据忽略对空字符串的检测）。比如战斗关卡表中，填写了通关后奖励道具的ID，需要检查这个ID是否存在于prop道具表中，以免人为疏忽填写成了一个不存在的ID。格式写法为：ref：表格名-列变量名，如果列为表格第一列，可以不显式声明列变量名。如果要进行参考的列为array或dict型的下属子元素，参照>=或>规则中索引字段声明的方式。特殊的，如果需要排除不需要进行引用检查的排除值，比如某关卡过关不奖励道具，约定了道具ID填-1或0表示此含义，那只需要在ref声明的最后添加小括号(except{-1,0})，如果是string型的排除值声明，参看上面②所述的格式，比如关卡ID若是string型，上面的规则变成(except{-1,0})或者(except{-1;0}(;))
⑦ $后面跟自定义的字符 表示自定义的取值范围规则，其具体规则在config文件中，比如游戏中道具品质目前为1,2,3共三级但以后很可能去增加更高品质，如果凡是各种表格用到此类型的都写为{1,2,3}，那以后新增就得把所有表格中这种检查条件全部手工修改一遍，非常不方便。故此功能允许自定义一个$propQuality检查规则填写在表格中，在config中填写$propQuality:{1,2,3}
⑧ file 用于【string】型，要求输入的资源路径对应的资源必须在项目中存在，格式为file(扩展名):路径，填写的路径为相对项目Client目录的相对路径。如果file后直接写英文冒号而后加路径，单元格中必须每一个都写上扩展名（用于文件扩展名可能不同的特殊情况，不建议项目中出现此情况）。而如果file后在英文括号中声明文件的扩展名（仅允许一种），如file(png):\Assert\Resources\Texture\，单元格中则无需声明
⑨ func 用于复杂检测规则，当检查规则复杂到只能人为写函数去检查时使用，格式为func:checkReward，即func冒号后跟上自定义的函数名，函数写在MyCheckFunction.cs中。本工具会通过反射的方式调用对应函数进行检查，比如一个reward是通过dict[3] type(int)、id(int)、count(int)来定义的，通过自定义检查函数就可以检查类型是否存在，如果是英雄类型检查id在Hero表中是否存在，如果是道具类型，检查id在Prop表中是否存在。并且检查奖励的数量是否大于0等等
目前在MyCheckFunction中提供了用于检查奖励列表是否正确的CheckRewardListField函数作为样例，该函数对字段进行如下检查：要求字段的数据结构必须为array[dict[3]:n]，定义一种奖励类型的三个int型字段分别叫type、id、count，每个奖励项的类型必须存在，除道具类型之外不允许奖励同一种类型，奖励数量必须大于0，如果是道具类型则道具id在道具表中要存在

如果需要多个检查规则，两个相邻规则之间用&&隔开，但需要自己注意规则是否合理不能互相冲突

---------------------------------------------------------------------------------------------------------